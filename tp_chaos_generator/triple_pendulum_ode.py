""" Triple Pendulum ODE """
import numpy as np
from scipy.integrate import solve_ivp

from .utils import normalize_states, state_plotter, trajectory_plotter


def triple_pendulum_ode(start, end, step, ivp) -> list:
    """ Solve ODE """
    params = ivp[6:19]
    xinit = ivp[0:6]

    tspan = np.arange(start, end, step)
    sol = solve_ivp(lambda t, x: f(t, x, params), [start, end], xinit, t_eval=tspan, rtol=1e-5)

    t, y = sol.t, sol.y
    y = normalize_states(y)

    return [t, y]


def f(t, x, params) -> list:
    """ ODE Function """
    m1, m2, m3, L1, L2, L3, I1, I2, I3, k1, k2, k3, g = params
    y0 = x[3]
    y1 = x[4]
    y2 = x[5]
    y3 = - (2 * (((L3 ** 2) * (m3 ** 2) * np.sin(2 * x[0] - 2 * x[2])
        * (4 * I2 - (L2 ** 2) * m2) + (L2 ** 2) * np.sin(2 * x[0] - 2 * x[1])
        * (m2 + 2 * m3) * (m2 * m3 * (L3 ** 2) + 4 * I3 * (m2 + 2 * m3)))
        * (L1 ** 2) * (x[3] ** 2) + (L2 * (np.sin(x[0] - x[1])
        * ((m2 * m3 * (m2 + 3 * m3) * (L3 ** 2) + 4 * I3 * ((m2 ** 2)
        + 6 * m2 * m3 + 8 * (m3 ** 2))) * (L2 ** 2) + 4 * I2
        * (m3 * (m2 + m3) * (L3 ** 2) + 4 * I3 * (m2 + 2 * m3)))
        + (L3 ** 2) * (m3 ** 2) * np.sin(x[0] + x[1] - 2 * x[2])
        * (4 * I2 - (L2 ** 2) * m2)) * (x[4] ** 2) - 4 * k2 * L2
        * (np.cos(x[0] - x[1]) * (m3 * (m2 + m3) * (L3 ** 2)
        + 4 * I3 * (m2 + 2 * m3)) - (L3 ** 2) * (m3 ** 2) * np.cos(x[0]
        + x[1] - 2 * x[2])) * (x[4] ** 2) + L3 * m3 * (np.sin(x[0] - x[2])
        * (8 * I3 * m3 * (L2 ** 2) + 4 * I2 * m3 * (L3 ** 2) + 16 * I2 * I3)
        + (L2 ** 2) * np.sin(x[0] - 2 * x[1] + x[2]) * (m2 * m3 * (L3 ** 2)
        + 4 * I3 * (m2 + 2 * m3))) * (x[5] ** 2) - 4 * k3 * L3 * m3
        * (np.cos(x[0] - x[2]) * (2 * m3 * (L2 ** 2) + 4 * I2)
        - (L2 ** 2) * np.cos(x[0] - 2 * x[1] + x[2]) * (m2 + 2 * m3))
        * x[5] - g * (np.sin(x[0]) * ((m3 * (m1 * m2 + 2 * m1 * m3
        + 3 * m2 * m3 + (m2 ** 2)) * (L3 ** 2) + 4 * I3 * ((m2 ** 2)
        + 6 * m2 * m3 + m1 * m2 + 4 * (m3 ** 2) + 4 * m1 * m3)) * (L2 ** 2)
        + 4 * I2 * (m3 * (m1 + 2 * m2 + m3) * (L3 ** 2) + 4 * I3
        * (m1 + 2 * m2 + 2 * m3))) + (L3 ** 2) * (m3 ** 2)
        * (np.sin(x[0] - 2 * x[2]) * (4 * I2 - (L2 ** 2) * m2)
        - 2 * (L2 ** 2) * np.cos(2 * x[1] - 2 * x[2]) * np.sin(x[0])
        * (m1 + m2)) + (L2 ** 2) * np.sin(x[0] - 2 * x[1]) * (m2 + 2 * m3)
        * (m2 * m3 * (L3 ** 2) + 4 * I3 * (m2 + 2 * m3)))) * L1 + 2 * k1
        * (4 * I2 * (m3 * (L3 ** 2) + 4 * I3) + (L2 ** 2) * (m3 * (m2 + 2 * m3)
        * (L3 ** 2) + 4 * I3 * (m2 + 4 * m3)) - 2 * (L2 ** 2) * (L3 ** 2)
        * (m3 ** 2) * np.cos(2 * x[1] - 2 * x[2])) * x[0])) / (64 * I1 * I2 * I3
        + 8 * I3 * (L1 ** 2) * (L2 ** 2) * (m2 ** 2) + 8 * I1 * (L2 ** 2)
        * (L3 ** 2) * (m3 ** 2) + 8 * I2 * (L1 ** 2) * (L3 ** 2) * (m3 ** 2)
        + 32 * I3 * (L1 ** 2) * (L2 ** 2) * (m3 ** 2) + 16 * I2 * I3 * (L1 ** 2)
        * m1 + 16 * I1 * I3 * (L2 ** 2) * m2 + 64 * I2 * I3 * (L1 ** 2) * m2
        + 16 * I1 * I2 * (L3 ** 2) * m3 + 64 * I1 * I3 * (L2 ** 2) * m3 
        + 64 * I2 * I3 * (L1 ** 2) * m3 + 4 * I3 * (L1 ** 2) * (L2 ** 2) * m1 * m2
        + 4 * I2 * (L1 ** 2) * (L3 ** 2) * m1 * m3 + 16 * I3 * (L1 ** 2) * (L2 ** 2)
        * m1 * m3 + 4 * I1 * (L2 ** 2) * (L3 ** 2) * m2 * m3 + 16 * I2 * (L1 ** 2)
        * (L3 ** 2) * m2 * m3 + 48 * I3 * (L1 ** 2) * (L2 ** 2) * m2 * m3
        - 8 * I1 * (L2 ** 2) * (L3 ** 2) * (m3 ** 2) * np.cos(2 * x[1] - 2 * x[2])
        - 2 * (L1 ** 2) * (L2 ** 2) * np.cos(2 * x[0] - 2 * x[1]) * (m2 + 2 * m3)
        * (m2 * m3 * (L3 ** 2) + 4 * I3 * (m2 + 2 * m3)) - 2 * (L1 ** 2) * (L3 ** 2)
        * (m3 ** 2) * np.cos(2 * x[0] - 2 * x[2]) * (- m2 * (L2 ** 2) + 4 * I2)
        + 2 * (L1 ** 2) * (L2 ** 2) * (L3 ** 2) * m1 * (m3 ** 2) + 6 * (L1 ** 2)
        * (L2 ** 2) * (L3 ** 2) * m2 * (m3 ** 2) + 2 * (L1 ** 2) * (L2 ** 2)
        * (L3 ** 2) * (m2 ** 2) * m3 + (L1 ** 2) * (L2 ** 2) * (L3 ** 2)
        * m1 * m2 * m3 - 2 * (L1 ** 2) * (L2 ** 2) * (L3 ** 2) * m1
        * (m3 ** 2) * np.cos(2 * x[1] - 2 * x[2]) - 4 * (L1 ** 2) * (L2 ** 2)
        * (L3 ** 2) * m2 * (m3 ** 2) * np.cos(2 * x[1] - 2 * x[2]))

    y4 = (2 * (((L1 ** 2) * np.sin(2 * x[0] - 2 * x[1]) * (m2 + 2 * m3)
        * (m2 * m3 * (L3 ** 2) + 4 * I3 * (m2 + 2 * m3)) - (L3 ** 2)
        * (m3 ** 2) * np.sin(2 * x[1] - 2 * x[2]) * ((m1 + 2 * m2)
        * (L1 ** 2) + 4 * I1)) * (L2 ** 2) * (x[4] ** 2) + L1 * (np.sin(x[0]
        - x[1]) * ((m3 * (m1 * (m2 + m3) + 2 * m2 * (2 * m2 + 3 * m3))
        * (L3 ** 2) + 4 * I3 * (m2 + 2 * m3) * (m1 + 4 * m2 + 4 * m3))
        * (L1 ** 2) + 4 * I1 * (m3 * (m2 + m3) * (L3 ** 2) + 4 * I3
        * (m2 + 2 * m3))) - (L3 ** 2) * (m3 ** 2) * np.sin(x[0] + x[1]
        - 2 * x[2]) * ((m1 + 2 * m2) * (L1 ** 2) + 4 * I1)) * L2 * (x[3] ** 2)
        + 4 * k1 * L1 * (np.cos(x[0] - x[1]) * (m3 * (m2 + m3) * (L3 ** 2)
        + 4 * I3 * (m2 + 2 * m3)) - (L3 ** 2) * (m3 ** 2) * np.cos(x[0] + x[1]
        - 2 * x[2])) * L2 * x[3] + (- L3 * m3 * (np.sin(x[1] - x[2])
        * ((m3 * (m1 + 3 * m2) * (L3 ** 2) + 4 * I3 * (m1 + 3 * m2 + 2 * m3))
        * (L1 ** 2) + 4 * I1 * (m3 * (L3 ** 2) + 4 * I3)) - (L1 ** 2)
        * np.sin(2 * x[0] - x[1] - x[2]) * (m2 * m3 * (L3 ** 2) + 4 * I3
        * (m2 + 2 * m3))) * (x[5] ** 2) + 4 * k3 * L3 * m3 * (np.cos(x[1] - x[2])
        * ((m1 + 3 * m2 + 2 * m3) * (L1 ** 2) + 4 * I1) - (L1 ** 2)
        * np.cos(2 * x[0] - x[1] - x[2]) * (m2 + 2 * m3)) * x[5] + g * (np.sin(x[1])
        * ((m2 * m3 * (2 * m2 + 3 * m3) * (L3 ** 2) + 8 * I3 * ((m2 ** 2)
        + 3 * m2 * m3 + 2 * (m3 ** 2))) * (L1 ** 2) + 4 * I1 * (m3 * (m2 + m3)
        * (L3 ** 2) + 4 * I3 * (m2 + 2 * m3))) - (L1 ** 2) * np.sin(2 * x[0] - x[1])
        * (m3 * (m1 * (m2 + m3) + m2 * (2 * m2 + 3 * m3)) * (L3 ** 2) + 4 * I3
        * (m2 + 2 * m3) * (m1 + 2 * m2 + 2 * m3)) + (L3 ** 2) * (m3 ** 2)
        * (np.sin(x[1] - 2 * x[2]) * (m2 * (L1 ** 2) + 4 * I1) + (L1 ** 2)
        * np.sin(2 * x[0] + x[1] - 2 * x[2]) * (m1 + m2)))) * L2 - 2 * k2
        * (4 * I1 * (m3 * (L3 ** 2) + 4 * I3) + (L1 ** 2) * (m3 * (m1 + 4 * m2 + 2 * m3)
        * (L3 ** 2) + 4 * I3 * (m1 + 4 * m2 + 4 * m3)) - 2 * (L1 ** 2) * (L3 ** 2)
        * (m3 ** 2) * np.cos(2 * x[0] - 2 * x[2])) * (x[4] ** 2)))/(64 * I1 * I2 * I3
        + 8 * I3 * (L1 ** 2) * (L2 ** 2) * (m2 ** 2) + 8 * I1 * (L2 ** 2) * (L3 ** 2)
        * (m3 ** 2) + 8 * I2 * (L1 ** 2) * (L3 ** 2) * (m3 ** 2) + 32 * I3 * (L1 ** 2)
        * (L2 ** 2) * (m3 ** 2) + 16 * I2 * I3 * (L1 ** 2) * m1 + 16 * I1 * I3 * (L2 ** 2)
        * m2 + 64 * I2 * I3 * (L1 ** 2) * m2 + 16 * I1 * I2 * (L3 ** 2) * m3
        + 64 * I1 * I3 * (L2 ** 2) * m3 + 64 * I2 * I3 * (L1 ** 2) * m3 + 4 * I3
        * (L1 ** 2) * (L2 ** 2) * m1 * m2 + 4 * I2 * (L1 ** 2) * (L3 ** 2) * m1 * m3
        + 16 * I3 * (L1 ** 2) * (L2 ** 2) * m1 * m3 + 4 * I1 * (L2 ** 2) * (L3 ** 2) * m2 * m3
        + 16 * I2 * (L1 ** 2) * (L3 ** 2) * m2 * m3 + 48 * I3 * (L1 ** 2) * (L2 ** 2)
        * m2 * m3 - 8 * I1 * (L2 ** 2) * (L3 ** 2) * (m3 ** 2) * np.cos(2 * x[1] - 2 * x[2])
        - 2 * (L1 ** 2) * (L2 ** 2) * np.cos(2 * x[0] - 2 * x[1]) * (m2 + 2 * m3)
        * (m2 * m3 * (L3 ** 2) + 4 * I3 * (m2 + 2 * m3)) - 2 * (L1 ** 2) * (L3 ** 2)
        * (m3 ** 2) * np.cos(2 * x[0] - 2 * x[2]) * (- m2 * (L2 ** 2) + 4 * I2) + 2
        * (L1 ** 2) * (L2 ** 2) * (L3 ** 2) * m1 * (m3 ** 2) + 6 * (L1 ** 2) * (L2 ** 2)
        * (L3 ** 2) * m2 * (m3 ** 2) + 2 * (L1 ** 2) * (L2 ** 2) * (L3 ** 2) * (m2 ** 2) * m3
        + (L1 ** 2) * (L2 ** 2) * (L3 ** 2) * m1 * m2 * m3 - 2 * (L1 ** 2) * (L2 ** 2)
        * (L3 ** 2) * m1 * (m3 ** 2) * np.cos(2 * x[1] - 2 * x[2]) - 4 * (L1 ** 2)
        * (L2 ** 2) * (L3 ** 2) * m2 * (m3 ** 2) * np.cos(2 * x[1] - 2 * x[2]))

    y5 = - (2 * (32 * I1 * I2 * k3 * x[5] - L2 * L3 * m3 * (x[4] ** 2) * (np.sin(x[1] - x[2])
        * (((L2 ** 2) * (m1 * m2 + 4 * m1 * m3 + 6 * m2 * m3 + (m2 ** 2)) + 4 * I2
        * (m1 + 3 * m2 + 2 * m3)) * (L1 ** 2) + 4 * I1 * (4 * I2 + (L2 ** 2)
        * (m2 + 4 * m3))) + (L1 ** 2) * np.sin(2 * x[0] - x[1] - x[2]) * (m2 + 2 * m3)
        * (4 * I2 - m2 * (L2 ** 2))) - L1 * L3 * m3 * (x[3] ** 2) * (np.sin(x[0] - x[2])
        * (8 * I1 * (m3 * (L2 ** 2) + 2 * I2) + 2 * (L1 ** 2) * ((m1 * m3 - (m2 ** 2))
        * (L2 ** 2) + 2 * I2 * (m1 + 4 * m2 + 4 * m3))) - (L2 ** 2) * np.sin(x[0]
        - 2 * x[1] + x[2]) * (m2 + 2 * m3) * ((m1 + 2 * m2) * (L1 ** 2) + 4 * I1))
        + 4 * k3 * (L1 ** 2) * (L2 ** 2) * (m2 ** 2) * x[5] + 16 * k3 * (L1 ** 2) * (L2 ** 2)
        * (m3 ** 2) * x[5] + 8 * I2 * k3 * (L1 ** 2) * m1 * x[5] + 8 * I1 * k3 * (L2 ** 2)
        * m2 * x[5] + 32 * I2 * k3 * (L1 ** 2) * m2 * x[5] + 32 * I1 * k3 * (L2 ** 2) * m3
        * x[5] + 32 * I2 * k3 * (L1 ** 2) * m3 * x[5] - 4 * k1 * L1 * L3 * m3 * x[3]
        * (np.cos(x[0] - x[2]) * (2 * m3 * (L2 ** 2) + 4 * I2) - (L2 ** 2) * np.cos(x[0]
        - 2 * x[1] + x[2]) * (m2 + 2 * m3)) - 16 * I1 * I2 * g * L3 * m3 * np.sin(x[2])
        - 4 * I2 * (L1 ** 2) * (L3 ** 2) * (m3 ** 2) * (x[5] ** 2) * np.sin(2 * x[0] - 2 * x[2])
        - 4 * I1 * (L2 ** 2) * (L3 ** 2) * (m3 ** 2) * (x[5] ** 2) * np.sin(2 * x[1] - 2 * x[2])
        + 8 * I2 * g * (L1 ** 2) * L3 * (m3 ** 2) * np.sin(2 * x[0] - x[2]) + 8 * I1 * g *
        (L2 ** 2) * L3 * (m3 ** 2) * np.sin(2 * x[1] - x[2]) + 2 * k3 * (L1 ** 2) * (L2 ** 2)
        * m1 * m2 * x[5] + 8 * k3 * (L1 ** 2) * (L2 ** 2) * m1 * m3 * x[5] + 24 * k3 * (L1 ** 2)
        * (L2 ** 2) * m2 * m3 * x[5] - 4 * k2 * L2 * L3 * m3 * x[4] * (np.cos(x[1] - x[2])
        * ((m1 + 3 * m2 + 2 * m3) * (L1 ** 2) + 4 * I1) - (L1 ** 2) * np.cos(2 * x[0] - x[1]
        - x[2]) * (m2 + 2 * m3)) - 8 * I1 * g * (L2 ** 2) * L3 * (m3 ** 2) * np.sin(x[2])
        - 8 * I2 * g * (L1 ** 2) * L3 * (m3 ** 2) * np.sin(x[2]) - 4 * k3 * (L1 ** 2)
        * (L2 ** 2) * (m2 ** 2) * x[5] * np.cos(2 * x[0] - 2 * x[1]) - 16 * k3 * (L1 ** 2)
        * (L2 ** 2) * (m3 ** 2) * x[5] * np.cos(2 * x[0] - 2 * x[1]) - 8 * I2 * g * (L1 ** 2)
        * L3 * m2 * m3 * np.sin(x[2]) - 16 * k3 * (L1 ** 2) * (L2 ** 2) * m2 * m3 * x[5]
        * np.cos(2 * x[0] - 2 * x[1]) - (L1 ** 2) * (L2 ** 2) * (L3 ** 2) * m1 * (m3 ** 2)
        * (x[5] ** 2) * np.sin(2 * x[1] - 2 * x[2]) + (L1 ** 2) * (L2 ** 2) * (L3 ** 2)
        * m2 * (m3 ** 2) * (x[5] ** 2) * np.sin(2 * x[0] - 2 * x[2]) - 2 * (L1 ** 2) * (L2 ** 2)
        * (L3 ** 2) * m2 * (m3 ** 2) * (x[5] ** 2) * np.sin(2 * x[1] - 2 * x[2]) + 2 * g
        * (L1 ** 2) * (L2 ** 2) * L3 * m1 * (m3 ** 2) * np.sin(2 * x[0] - x[2]) - g * (L1 ** 2)
        * (L2 ** 2) * L3 * (m2 ** 2) * m3 * np.sin(2 * x[0] - x[2]) + 2 * g * (L1 ** 2)
        * (L2 ** 2) * L3 * m2 * (m3 ** 2) * np.sin(2 * x[1] - x[2]) + g * (L1 ** 2) * (L2 ** 2)
        * L3 * (m2 ** 2) * m3 * np.sin(2 * x[1] - x[2]) + 4 * I2 * g * (L1 ** 2) * L3 * m1 * m3
        * np.sin(2 * x[0] - x[2]) + 8 * I2 * g * (L1 ** 2) * L3 * m2 * m3 * np.sin(2 * x[0]
        - x[2]) + 4 * I1 * g * (L2 ** 2) * L3 * m2 * m3 * np.sin(2 * x[1] - x[2]) - 2 * g
        * (L1 ** 2) * (L2 ** 2) * L3 * m1 * (m3 ** 2) * np.sin(2 * x[0] - 2 * x[1] + x[2])
        - 2 * g * (L1 ** 2) * (L2 ** 2) * L3 * m2 * (m3 ** 2) * np.sin(2 * x[0] - 2 * x[1]
        + x[2]) - g * (L1 ** 2) * (L2 ** 2) * L3 * (m2 ** 2) * m3 * np.sin(2 * x[0]
        - 2 * x[1] + x[2]) + g * (L1 ** 2) * (L2 ** 2) * L3 * (m2 ** 2) * m3 * np.sin(x[2])
        - g * (L1 ** 2) * (L2 ** 2) * L3 * m1 * m2 * m3 * np.sin(2 * x[0] - 2 * x[1] + x[2]))) \
        / (64 * I1 * I2 * I3 + 8 * I3 * (L1 ** 2) * (L2 ** 2) * (m2 ** 2) + 8 * I1 * (L2 ** 2)
        * (L3 ** 2) * (m3 ** 2) * + 8 * I2 * (L1 ** 2) * (L3 ** 2) * (m3 ** 2) + 32 * I3
        * (L1 ** 2) * (L2 ** 2) * (m3 ** 2) + 16 * I2 * I3 * (L1 ** 2) * m1 + 16 * I1 * I3
        * (L2 ** 2) * m2 + 64 * I2 * I3 * (L1 ** 2) * m2 + 16 * I1 * I2 * (L3 ** 2) * m3
        + 64 * I1 * I3 * (L2 ** 2) * m3 + 64 * I2 * I3 * (L1 ** 2) * m3 + 4 * I3 * (L1 ** 2)
        * (L2 ** 2) * m1 * m2 + 4 * I2 * (L1 ** 2) * (L3 ** 2) * m1 * m3 + 16 * I3 * (L1 ** 2)
        * (L2 ** 2) * m1 * m3 + 4 * I1 * (L2 ** 2) * (L3 ** 2) * m2 * m3 + 16 * I2 * (L1 ** 2)
        * (L3 ** 2) * m2 * m3 + 48 * I3 * (L1 ** 2) * (L2 ** 2) * m2 * m3 - 8 * I1 * (L2 ** 2)
        * (L3 ** 2) * (m3 ** 2) * np.cos(2 * x[1] - 2 * x[2]) - 2 * (L1 ** 2) * (L2 ** 2)
        * np.cos(2 * x[0] - 2 * x[1]) * (m2 + 2 * m3) * (m2 * m3 * (L3 ** 2) + 4 * I3
        * (m2 + 2 * m3)) - 2 * (L1 ** 2) * (L3 ** 2) * (m3 ** 2) * np.cos(2 * x[0] - 2 * x[2])
        * (4 * I2 - m2 * (L2 ** 2)) + 2 * (L1 ** 2) * (L2 ** 2) * (L3 ** 2) * m1 * (m3 ** 2)
        + 6 * (L1 ** 2) * (L2 ** 2) * (L3 ** 2) * m2 * (m3 ** 2) + 2 * (L1 ** 2) * (L2 ** 2)
        * (L3 ** 2) * (m2 ** 2) * m3 + (L1 ** 2) * (L2 ** 2) * (L3 ** 2) * m1 * m2 * m3
        - 2 * (L1 ** 2) * (L2 ** 2) * (L3 ** 2) * m1 * (m3 ** 2) * np.cos(2 * x[1] - 2 * x[2])
        - 4 * (L1 ** 2) * (L2 ** 2) * (L3 ** 2) * m2 * (m3 ** 2) * np.cos(2 * x[1] - 2 * x[2]))

    dydt = [y0, y1, y2, y3, y4, y5]
    return dydt


def main():
    """ Main """
    m1 = 0.2944
    m2 = 0.1765
    m3 = 0.0947
    l1 = 0.508
    l2 = 0.254
    l3 = 0.127
    k1 = 0.005
    k2 = 0
    k3 = 0.0008
    I1 = 9.526e-3
    I2 = 1.625e-3
    I3 = 1.848e-4
    g = 9.81

    theta1 = -0.4603
    theta2 = -1.2051
    theta3 = -1.5165
    dtheta1 = 0
    dtheta2 = 0
    dtheta3 = 0

    key = [theta1, theta2, theta3, dtheta1, dtheta2, dtheta3,
          m1, m2, m3, l1, l2, l3, I1, I2, I3, k1, k2, k3, g]

    start = 0
    stop = 10
    fps = 10000
    delta_t = 1.0 / fps
    t, y = triple_pendulum_ode(start, stop, delta_t, key)

    state_plotter(t, y, 1)
    trajectory_plotter(y, key)


if __name__ == "__main__":
    main()
